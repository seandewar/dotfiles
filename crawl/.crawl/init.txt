# Sean's Dungeon Crawl: Stone Soup configuration file, for v0.32.
#
# If you're reading this, then here's a secret: if you're on WebTiles (and
# suffer from performance anxiety :-[), it's possible to disable spectators from
# watching your games! In the F12 chat, type "/block [anon]" to block anonymous
# spectators, or "/block [all]" to block everyone. Have fun!

hp_warning = 75
mp_warning = 50
autofight_stop = 75
default_manual_training = true
warn_hatches = true
always_show_gems = true

explore_delay = -1
rest_delay = -1
rest_wait_both = true
rest_wait_ancestor = true
travel_delay = -1
show_travel_trail = true

bindkey = [Tab] CMD_AUTOFIGHT_NOMOVE
autofight_nomove_fires = false

action_panel_show = false
tile_realtime_anim = true
tile_show_threat_levels = tough, nasty, unusual
tile_web_mouse_control = false

show_more = false
force_more_message += A sentinel's mark forms upon you
force_more_message += [Tt]raining target.*reached
force_more_message += You have finished your manual
force_more_message += You now have enough gold
force_more_message += You miscast
force_more_message += You fail to use your ability
force_more_message += seems mollified
force_more_message += burns out of existence
force_more_message += The sign of ruin forms upon you!$
force_more_message += Your magic feels.*tainted

# These items are good, but can be dangerous if used accidentally.
# Prompt for them, as the game does not do this automatically.
autoinscribe += potions? of ambrosia:!q
autoinscribe += potions? of berserk rage:!q
autoinscribe += potions? of cancellation:!q
autoinscribe += scrolls? of poison:!r
autoinscribe += scrolls? of silence:!r
autoinscribe += scrolls? of teleportation:!r

# Nets are rare; don't want to accidentally throw or automatically quiver them.
autoinscribe += throwing net:!f =f

autopickup_exceptions += <curare-tipped dart
autopickup_exceptions += <throwing net
autopickup_exceptions += >scrolls? of noise

spell_slot ^= Blink:B
spell_slot ^= Passage of Golubria:G
spell_slot ^= Passwall:P
spell_slot ^= Swiftness:S
spell_slot ^= Apportation:Z

macros += M o ===explore_skip_doors
macros += M \{F2} ===toggle_fun_mode

{
local reset_travel_open_doors = false

-- Auto-explore while avoiding doors. Doesn't affect other automatic travel.
function explore_skip_doors()
  crawl.setopt "travel_open_doors = avoid"
  crawl.do_commands {"CMD_EXPLORE"}
  reset_travel_open_doors = true
end

local dangerous_foes, dangerous_foes_place

-- Update the list of dangerous foes in our line of sight, and force a
-- "-- more --" prompt if new such foes appeared since the last call.
local function update_dangerous_foes()
  local place = you.where()
  local new_place = place ~= dangerous_foes_place
  if new_place then
    dangerous_foes = {}
    dangerous_foes_place = place
  end

  local los, willpower, xl = you.los(), you.willpower(), you.xl()
  local high_threat, lethal_threat = 2, 3  -- MTHRT_TOUGH and MTHRT_NASTY
  local danger_threat = xl < 5 and high_threat or lethal_threat
  local foes = {}
  for x = -los,los do
    for y = -los,los do
      local mons = monster.get_monster_at(x, y)
      if mons and not mons:is_safe() then
        local banishment = false
        -- The Abyss is very scary in most circumstances...
        if not you.immune_to_hex "Banishment" and willpower < 4 and xl < 23 then
          for _, spell in ipairs(mons:spells()) do
            if spell == "Banishment" then
              banishment = true
              break
            end
          end
        end

        local threat = mons:threat()
        if threat >= danger_threat or banishment then
          local name = mons:name()
          local entry = foes[name]
          if not entry then
            entry = { count = 0, max_threat = 0 }
            foes[name] = entry
          end

          entry.count = entry.count + 1
          entry.max_threat = math.max(entry.max_threat, threat)
          entry.banishment = entry.banishment or banishment
        end
      end
    end
  end

  local turns = you.turns()
  local msg_parts = {}
  for name, info in pairs(foes) do
    local entry = dangerous_foes[name]
    if not entry or turns >= entry.invalidate_on_turn then
      entry = { max_count = 0 }
      dangerous_foes[name] = entry
    end

    if info.count > entry.max_count then
      local threat_colour = info.max_threat == lethal_threat and "lightred" or
                            info.max_threat == high_threat and "yellow" or
                            "white"
      local diff = info.count - entry.max_count
      msg_parts[#msg_parts + 1] = ("<%s>%s%s</%s>%s"):format(
        threat_colour,
        name,
        diff > 1 and (" x %d"):format(diff) or "",
        threat_colour,
        info.banishment and " <magenta>(casts banishment)</magenta>" or "")

      entry.max_count = info.count
    end

    -- Apply a grace period; avoids spam from messages and "-- more --" prompts.
    entry.invalidate_on_turn = turns + 8
  end

  if #msg_parts > 0 then
    crawl.mpr(("Dangerous monster%s %s: %s!"):format(
                #msg_parts > 1 and "s" or "",
                new_place and "here" or "entered view",
                table.concat(msg_parts, ", ")),
              "warning")
    crawl.more()
  end
end

local new_mutation_msgs = false

-- Force --more-- for new mutation-related messages; they may be important.
-- force_more_message isn't used for this, as that will cause numerous prompts
-- if many mutations are changed within one turn.
local function handle_mutations_changed_msg()
  if not new_mutation_msgs then return end

  crawl.mpr("New mutations-related messages received this turn!", "mutation")
  crawl.more()
  new_mutation_msgs = false
end

function c_message(msg, chan)
  -- Messages like "You feel( rather)? odd for a moment." have no effect.
  local ignore_suffix = "odd for a moment."
  if chan == "mutation" and msg:sub(-#ignore_suffix) ~= ignore_suffix then
    new_mutation_msgs = true
  end
end

local fun_mode = false
local fun_mode_tile_choice_i

local function xomify_message(msg)
  local colours = {"blue", "green", "cyan", "red", "magenta", "lightblue",
                   "lightgreen", "lightcyan", "lightred", "lightmagenta",
                   "yellow"}
  local parts = {}
  for i = 1, #msg do
    local colour_i = 1 + crawl.random2(#colours)
    parts[#parts + 1] = ("<%s>"):format(colours[colour_i])
    parts[#parts + 1] = msg:sub(i, i)
    parts[#parts + 1] = ("</%s>"):format(colours[colour_i])
  end
  return table.concat(parts)
end

-- I'm canonically a shapeshifter!
local function update_fun_mode_player_tile(force)
  if not force and not crawl.x_chance_in_y(1, 4) then return end

  local choices = {"mons:curse toe", "mons:curse skull", "mons:killer klown",
                   "mons:murray", "mons:death cob", "mons:revenant",
                   "mons:aspiring flesh", "tile:mons_meatzerker"}
  local choice_i = 1 + crawl.random2(#choices)
  if choice_i == fun_mode_tile_choice_i then return end

  crawl.setopt("tile_player_tile = " .. choices[choice_i])
  fun_mode_tile_choice_i = choice_i
  crawl.mpr(xomify_message("Xom touches you!") ..
            " Your visage twists and deforms.")
end

function toggle_fun_mode()
  fun_mode = not fun_mode
  if fun_mode then
    crawl.setopt "fake_lang = grunt, jager, dwarven"
    update_fun_mode_player_tile(true)
  else
    crawl.setopt "fake_lang ="
    crawl.setopt "tile_player_tile = normal"
    fun_mode_tile_choice_i = nil
    crawl.mpr "Xom loses interest in you. Your form returns to normal."
  end
end

local display_skills = crawl.hints_type() ~= "tutorial" and you.turns() == 0

function ready()
  if reset_travel_open_doors then
    crawl.setopt "travel_open_doors = open"
    reset_travel_open_doors = false
  end

  if fun_mode then
    update_fun_mode_player_tile()
  end

  -- Open the skills menu if we've just started a game.
  -- We could do this outside of ready(), but then the initial "Welcome"
  -- messages won't be printed yet.
  if display_skills then
    crawl.do_commands {"CMD_DISPLAY_SKILLS"}
    display_skills = false
  end

  update_dangerous_foes()
  handle_mutations_changed_msg()
end
}
