""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"  Sean Dewar's Vim/Neovim Configuration <https://github.com/seandewar>        "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

"" Determine a runtime directory to store user data {{{1
" an alternative is using fnamemodify(expand('$MYVIMRC', ':p:h')), but if the
" vimrc file is in the home directory, we'll end up cluttering it...
function! GetUserDir()
    if has('nvim')
        if has('win32')
            return expand('~/AppData/Local/nvim')
        else
            return expand('~/.config/nvim')
        endif
    else
        if has('win32')
            return expand('~/vimfiles')
        else
            return expand('~/.vim')
        endif
    endif
endfunction
let $VIMUSERDIR = GetUserDir()

"" Plugin Configurations (using Plug) {{{1
" run :PlugInstall to install new plugins
call plug#begin($VIMUSERDIR . '/plugged')

" utilities
Plug 'w0rp/ale' " vim8/nvim async linting engine + lsp support
Plug 'SirVer/ultisnips' " snippets engine
Plug 'tpope/vim-commentary'
Plug 'easymotion/vim-easymotion' " easier motions using <leader><leader>
Plug 'derekwyatt/vim-fswitch' " switch between companion files (.h, .c/.cc etc.)
Plug 'tpope/vim-fugitive' " git integration
Plug 'plasticboy/vim-markdown'
Plug 'sheerun/vim-polyglot' " language support package
Plug 'tpope/vim-repeat' " repeat command (.) support for plugins
Plug 'mhinz/vim-startify' " start screen
Plug 'tpope/vim-surround'
Plug 'tpope/vim-vinegar' " enhancements for the netrw directory viewer

" appearance
Plug 'itchyny/lightline.vim' | Plug 'maximbaz/lightline-ale'
Plug 'gruvbox-community/gruvbox' " colour scheme

call plug#end()

"" Vim Behaviour {{{1
set secure " disable unsafe commands in local vimrc files

" don't crowd working directories with swap files. we'll use the same path
" regardless of nvim/vim so both programs are able to detect the same swap files
if !isdirectory(expand('~/.vim/swap'))
    call mkdir(expand('~/.vim/swap'), 'p')
endif
set directory^=~/.vim/swap//

" use ripgrep over grep if available
if executable('rg')
    set grepprg=rg\ --vimgrep
endif

filetype plugin indent on " ensure file type and file indent detection is on
set backspace=indent,eol,start " backspace settings
set belloff=all " disable bell noises
set completeopt=menuone,preview " configure completion menu
set encoding=utf8 fileencoding=utf8 termencoding=utf8 " char encodings
set foldmethod=marker " enable text markers in files for automatic folding
set hidden " don't unload modified buffers that are not currently in a window
set hlsearch incsearch ignorecase smartcase " search options
set laststatus=2 showtabline=2 " always display the status and tab lines
set scrolloff=1 " always show at least 1 line above or below the cursor
set sessionoptions+=localoptions " save local option settings in sessions
set spelllang=en_gb " spellchecking language en_GB and off by default
set splitbelow splitright " split new windows on the bottom & right
set textwidth=80 " wrap text at 80 col (ftplugins may override this)
set timeoutlen=1500 " wait longer for key timeouts
set title " display open file name in terminal title bar

" don't indent C/C++ switch cases, class access specifiers & namespace blocks
set cinoptions+=:0,g0,N-s

" don't hide cursor when typing, right-click displays context menu
" ('mouse' is not set, so mouse support is disabled by default for terminals)
set nomousehide mousemodel=popup

" set tab sizes - treat tabs as 8 spaces (as they typically are), insert 4
" spaces when we use tabs or an auto indent, use shiftwidth instead of tabstop
" when inserting tab at the beginning of a line
set tabstop=8 softtabstop=4 shiftwidth=4 autoindent expandtab smarttab

" completion matches for commands (after pressing <tab> or ^D for a list &
" <tab><tab> for the wildmenu)
set wildmenu wildmode=list:longest,full wildignorecase

" enforced settings regardless of ftplugin options (easier than creating an
" ftplugin-specific script in .vim/after, but can fail if the ftplugin also
" creates its own autocmd...)
augroup EnforceFileTypeSettings
    autocmd!
    autocmd FileType * setlocal formatoptions=croqljn
    autocmd FileType c,cpp setlocal commentstring=//\ %s
augroup END

" close completion preview after finishing completion
augroup AutoCloseCompletionPreview
    autocmd!
    autocmd CompleteDone * pclose
augroup END

" startify bookmarks
let g:startify_bookmarks = []
if exists('$MYVIMRC')
    let g:startify_bookmarks += [ { 'V': $MYVIMRC } ]
endif

" configure ultisnips - I like to store my snippets globally
let g:UltiSnipsEditSplit = 'horizontal'
let g:UltiSnipsSnippetsDir = $VIMUSERDIR . '/MyUltiSnips'
let g:UltiSnipsSnippetDirectories = [ g:UltiSnipsSnippetsDir ]

" ale fixing and linting preferences
let g:ale_fixers = {
            \ 'markdown': [ 'remove_trailing_lines' ],
            \ 'cpp': [ 'clang-format', 'remove_trailing_lines',
                     \ 'trim_whitespace' ],
            \ 'rust': [ 'rustfmt', 'remove_trailing_lines', 'trim_whitespace' ],
            \ '*': [ 'remove_trailing_lines', 'trim_whitespace' ]
            \ }
let g:ale_c_clangformat_options = '-fallback-style=none'
let g:ale_linters = {
            \ 'c': [ ],
            \ 'cpp': [ ],
            \ 'rust': [ 'rls', 'cargo' ]
            \ }
let g:ale_fix_on_save = 1

"" Vim Appearance {{{1
syntax on " syntax highlighting
set list listchars=tab:.. " show tab characters (useful for snippets)
set ruler " show line/col number of cursor position
set showtabline=1 " only show the tabline if at least two tabs are open

" make sure we show hybrid relative line numbers on the side of all buffer
" windows (including windows to non-file buffers)
augroup AutoWindowNumber
    autocmd!
    autocmd BufWinEnter * setlocal number relativenumber
augroup END

" highlight the line that the cursor is on for the active window
augroup AutoWindowCursorLine
    autocmd!
    autocmd WinEnter * setlocal cursorline
    autocmd WinLeave * setlocal nocursorline
augroup END

" function hides colorcolumn in unmodifiable mode, otherwise sets to textwidth+1
function! ColorColumnUpdate()
    if &modifiable
        setlocal colorcolumn=+1
    else
        setlocal colorcolumn=
    endif
endfunction

" show the colorcolumn for the active window and update if modifiable is (un)set
augroup AutoWindowColorColumn
    autocmd!
    autocmd OptionSet modifiable call ColorColumnUpdate()
    autocmd WinEnter,BufWinEnter * call ColorColumnUpdate()
    autocmd WinLeave * setlocal colorcolumn=
augroup END

let c_no_curly_error = 1 " for C++11, don't highlight {} inside [] as a mistake

" make sure we see numbers in netrw and file timestamp & size info
let g:netrw_bufsettings = 'nomodifiable nomodified number relativenumber
            \ nobuflisted readonly'
let g:netrw_liststyle = 1

" ale gutter error/warning symbols and message configuration
let g:ale_sign_column_always = 1
let g:ale_sign_error = 'E>'
let g:ale_sign_warning = 'W>'
let g:ale_echo_msg_error_str = 'error'
let g:ale_echo_msg_warning_str = 'warning'
let g:ale_echo_msg_info_str = 'info'
let g:ale_echo_msg_format = '[%severity%] %s [%linter%]'

" lightline-ale symbols
let g:lightline#ale#indicator_errors = 'E:'
let g:lightline#ale#indicator_warnings = 'W:'
let g:lightline#ale#indicator_checking = 'Linting...'
let g:lightline#ale#indicator_ok = 'Lint OK'

" configure lightline and its color scheme
let g:lightline = {
            \ 'component_expand': {
            \   'linter_checking': 'lightline#ale#checking',
            \   'linter_errors': 'lightline#ale#errors',
            \   'linter_warnings': 'lightline#ale#warnings',
            \   'linter_ok': 'lightline#ale#ok'
            \ },
            \ 'component_type': {
            \   'linter_checking': 'left',
            \   'linter_errors': 'error',
            \   'linter_warnings': 'warning',
            \   'linter_ok': 'left'
            \ },
            \ 'component_function': { 'gitbranch': 'fugitive#head' },
            \ 'active': {
            \   'left': [ [ 'mode', 'paste' ],
            \             [ 'filename', 'readonly', 'modified', 'gitbranch' ] ],
            \   'right': [ [ 'linter_checking', 'linter_warnings',
            \                'linter_errors', 'linter_ok' ],
            \              [ 'spell' ],
            \              [ 'percent', 'lineinfo' ],
            \              [ 'fileformat', 'fileencoding', 'filetype' ] ]
            \ },
            \ 'inactive': {
            \   'left': [ [ 'filename', 'readonly', 'modified' ] ],
            \   'right': [ [ 'spell' ],
            \              [ 'percent', 'lineinfo' ],
            \              [ 'fileformat', 'fileencoding', 'filetype' ] ]
            \ },
            \ 'tabline': { 'left': [ [ 'tabs' ] ], 'right': [ [ '' ] ] }
            \ }

" function to refresh lightline
function! g:LightlineRefresh()
    if !exists('g:loaded_lightline')
        return
    endif
    call lightline#init()
    call lightline#colorscheme()
    call lightline#update()
endfunction

" configure vim colour scheme {{{2
" NOTE: check if we support 256+ colors, otherwise don't bother with gruvbox
" (e.g gruvbox lightline errors constantly if this requirement is not met)
set background=dark
if has('gui_running') || (has('termguicolors') && &termguicolors) || &t_Co == 256
    let g:gruvbox_contrast_dark = 'hard'

    " change bg colours instead of drawing underlines etc. in terminals as
    " they're not always supported
    if !has('gui_running')
        let g:gruvbox_guisp_fallback = 'bg'
    endif

    colorscheme gruvbox
    let g:lightline.colorscheme = 'gruvbox'
endif

"" Vim Keymappings {{{1
" general rebinds
" NOTE: make sure ^S flow control is disabled for the terminal if you want to
" use the ^S :write mapping. if you accidently activate flow control, press ^Q
" to unfreeze the terminal
nnoremap <silent> <f2> :Startify<cr>
inoremap <silent> <f2> <c-\><c-n>:Startify<cr>
nnoremap <silent> <f5> :setlocal paste!<cr>
inoremap <silent> <f5> <c-\><c-o>:setlocal paste!<cr>
nnoremap <silent> <f6> :setlocal spell!<cr>
inoremap <silent> <f6> <c-\><c-o>:setlocal spell!<cr>
nnoremap <c-s> :write<cr>
inoremap <c-s> <c-\><c-o>:write<cr>
nnoremap <silent> <leader>L :setlocal relativenumber!<cr>
nnoremap <leader>/ :nohlsearch<cr>

" configure ultisnips keybinds
let g:UltiSnipsExpandTrigger = '<c-j>'
let g:UltiSnipsListSnippets = '<c-k>'
let g:UltiSnipsJumpForwardTrigger = '<c-j>'
let g:UltiSnipsJumpBackwardTrigger = '<c-k>'

" netrw (dir explorer) keybinds
nnoremap <leader>dd :Explore<space>
nnoremap <leader>ds :Sexplore<space>
nnoremap <leader>dv :Vexplore<space>

" buffer keybinds
nnoremap <leader>bb :buffers<cr>:buffer<space>
nnoremap <leader>bs :buffers<cr>:sbuffer<space>
nnoremap <leader>bv :buffers<cr>:vertical sbuffer<space>
nnoremap <leader>bd :buffers<cr>:bdelete<space>
nnoremap <leader>bt :buffers<cr>:tab sbuffer<space>
nnoremap <leader>bn :bnext<cr>
nnoremap <leader>bN :bprevious<cr>

" loclist window keybinds
nnoremap <leader>ll :lopen<cr>
nnoremap <leader>ln :lnext<cr>
nnoremap <leader>lN :lprevious<cr>

" quickfix window keybinds
nnoremap <leader>cc :copen<cr>
nnoremap <leader>cn :cnext<cr>
nnoremap <leader>cN :cprevious<cr>

" configure startify session keybinds
nnoremap <leader>ss :SSave<cr>
nnoremap <leader>sl :SLoad<cr>
nnoremap <leader>sd :SDelete<cr>
nnoremap <leader>sc :SClose<cr>

" configure vim-fswitch keybinds
nnoremap <leader>oo :FSHere<cr>
nnoremap <leader>oh :FSLeft<cr>
nnoremap <leader>ol :FSRight<cr>
nnoremap <leader>ok :FSAbove<cr>
nnoremap <leader>oj :FSBelow<cr>
nnoremap <leader>oH :FSSplitLeft<cr>
nnoremap <leader>oL :FSSplitRight<cr>
nnoremap <leader>oK :FSSplitAbove<cr>
nnoremap <leader>oJ :FSSplitBelow<cr>

" configure vim-fugitive keybinds
nnoremap <leader>gg :Gstatus<cr>
nnoremap <leader>gs :Gstatus<cr>
nnoremap <silent> <leader>gl :Glog<cr>:copen<cr>
nnoremap <silent> <leader>gL :0Glog<cr>:copen<cr>
nnoremap <leader>ge :Gedit<cr>
nnoremap <leader>gd :Gdiffsplit<cr>
nnoremap <leader>gb :Gblame<cr>
nnoremap <leader>gc :Gcommit<cr>
nnoremap <leader>gC :Gcommit -a<cr>
nnoremap <leader>gw :Gwrite<cr>
nnoremap <leader>gr :Gread<cr>
nnoremap <leader>gps :Gpush<cr>
nnoremap <leader>gpl :Gpull<cr>

" configure ale keybinds (most of these binds only work for lsp servers)
imap <c-tab> <plug>(ale_complete)
nnoremap <leader>al :ALELint<cr>
nnoremap <leader>af :ALEFix<cr>
nnoremap <leader>ah :ALEHover<cr>
nnoremap <leader>as :ALESymbolSearch<space>
nnoremap <leader>ar :ALEFindReferences<cr>
nnoremap <leader>ad :ALEGoToDefinition<cr>
nnoremap <leader>aD :ALEGoToDefinitionInSplit<cr>
nnoremap <leader>at :ALEGoToTypeDefinition<cr>
nnoremap <leader>aT :ALEGoToTypeDefinitionInSplit<cr>
